<?php
    // показать массив: скомопновал всю логику вывода массива здесь для краткости кода в примерах
    function showArray($arr,$header = "Массив"){
        echo "<h3>$header</h3>";
        echo "<pre>";
        print_r($arr);
        echo "</pre>";
    };

    //=============  ОГЛАВЛЕНИЕ  =====================
    // ex1(); // is_array, проверка, что объект является массивом
    // ex2(); // count и sizeof -> подсчёт количества элементов массива - узнать длину массива
    // ex3(); // shuffle -> перемешивает элемены массива в случайном порядке. изменяет массив на месте
    // ex4(); // compact -> создание массива из переменных, где ключами становятся имена переменных, а значениями значения переменных
    // // ВАЖНО! В ФУНКЦИЯХ СОРТИРОВКИ asort и arsort  сохраняется ассоциация ключей (местами меняются значения, но индексы (и ключи) сохраняются)
    // ex5(); // asort -> сортировка массива по значениям по возрастанию, типы сортировки (дополнительные ключи SORT_REGULAR, SORT_NUMERIC, SORT_STRING)
    // ex6(); // arsort -> сортировка массива по значениям по убыванию, типы сортировки (дополнительные ключи SORT_REGULAR, SORT_NUMERIC, SORT_STRING)
    // ex7(); // ksort -> сортировка массива по ключам по возрастанию, при этом ассоциативность (ключ-значение) сохраняется
    // ex8(); // krsort -> сортировка массива по ключам по убыванию, при этом ассоциативность (ключ-значение) сохраняется
    // ex9(); // natsort -> натуральная (естественная) сортировка, алгоритм сортировки который сортирует элементы как в проводнике Windows
    // ex10(); // natcasesort -> натуральная (естественная) сортировка, но с игнорированием регистра
    // ex11(); // array_reverse -> развернуть массив, preserve_keys - сохранить связь ключ-значение (неактуально для нечисловых ключей)


    // array_reverse -> развернуть массив, preserve_keys - сохранить связь ключ-значение (неактуально для нечисловых ключей)
    function ex11(){
        /* 
        для простых случаев в принципе можно просто использовать обратную сортировку рассмотренную
        но также есть функция array_reverse которая меняет последовательность элементов на обратный 
        порядок.
        Если в качестве второго аргумента (preserve_keys) поставить true, то ключи будут сохраняться
        с своими элементами (это актуально для индексов, так как нечисловые ключи и так сохраняются)
        */
        $arr = ["a","b","c","d"];
        showArray($arr,header: "Исходный массив");

        // пример с несохранением связи ключ элемент:
        $arr1 = array_reverse($arr);
        showArray($arr1,header: "развернутый массив, порядок ключей изменился");

        // ставим true и связь ключ элемент сохраняется:
        $arr2 = array_reverse($arr, true);
        showArray($arr2,header: "развернутый массив, порядок ключей сохранился");
    }

    // natcasesort -> натуральная (естественная) сортировка, но с игнорированием регистра
    function ex10(){
        $applications = ["app_F", "app_a","app_c", "app_b","app_d", "app_W"];
        // игнорировать регистр при сортировке
        natcasesort($applications);
        showArray(arr: $applications, header: "отсортированный естественной сортировкой массив, без учёта регистра");
    }

    // natsort -> натуральная сортировка, алгоритм сортировки который сортирует элементы как в проводнике Windows
    function ex9(){
        /*
        Механизм естественной сортировки (работает примерно также как и в проводнике ос, когда фильтруем файлы)
        работает по принципу нахождения повторяющегося паттерна в элементах, то есть находит подстроку которая содержится
        в нескольких элементах массива и смотрит на его соседей, приоритетнее сосед слева, если его нет
        то берется сосед справа и сортируется по нему. Принцип тот-же если буквы то сортировать по алфавиту, если
        цифры то по возрастанию (или убыванию)
        Например в массиве ниже, повторяющийся рисунок "app", сосед слева отсутствует, значит сортировка
        будет выполнена по соседу справа, при этом приоритетнее будут цифры (они встанут в начало массива),
        а за тем уже буквы и символы.
        При этом если будет сосед справа у одного из элементов, то он встанет в начало массива это будет
        приоритетнее, см. "AappW" в массиве $applications
        */

        $applications = ["app6", "app1","appA", "app2","app_", "AappW"];
        natsort($applications);
        showArray(arr: $applications, header: "отсортированный естественной сортировкой массив");
    }

    // krsort -> сортировка массива по ключам по убыванию, при этом ассоциативность (ключ-значение) сохраняется
    function ex8(){
        $arr = ["Siemens" => "m 55","Nokia" => "3310", "Motorola" => "c 650", "Alcatel" => "c 100"];
        krsort($arr);
        showArray(arr: $arr, header: "отсортированный по ключам массив");
    }


    // ksort -> сортировка массива по ключам по возрастанию, при этом ассоциативность (ключ-значение) сохраняется
    function ex7(){
        $arr = ["Siemens" => "m 55","Nokia" => "3310", "Motorola" => "c 650", "Alcatel" => "c 100"];
        ksort($arr);
        showArray(arr: $arr, header: "отсортированный по ключам массив");
    }


    // arsort -> сортировка массива по значениям по убыванию, типы сортировки (дополнительные ключи SORT_REGULAR, SORT_NUMERIC, SORT_STRING)
    function ex6(){
        /*
        arsort - антагонист функции asort, она сортирует массив по убыванию
        */
        $arr = ["a","b","c","d","e","f","g"];
        shuffle($arr); // перемешать массив в случайном порядке
        showArray(arr: $arr, header: "Массив до сортировки");

        /* 
        применить функцию сортировки, arsort принимает сам массив который нужно отсортировать
        и тип сортировки (необязательный параметр):
        SORT_REGULAR - автоматический выбор сортировки (установлен по умолчанию)
        SORT_NUMERIC - числовая сортировка
        SORT_STRING - сортировка по алфавиту
        */

        arsort($arr);
        showArray(arr: $arr, header: "Отсортированный по убыванию массив");
    }

    // asort -> сортировка массива по значениям по возрастанию, типы сортировки (дополнительные ключи SORT_REGULAR, SORT_NUMERIC, SORT_STRING)
    function ex5(){
        $arr = ["a","b","c","d","e","f","g"];
        shuffle($arr); // перемешать массив в случайном порядке
        showArray(arr: $arr, header: "Массив до сортировки");

        /* 
        применить функцию сортировки, asort принимает сам массив который нужно отсортировать
        и тип сортировки (необязательный параметр):
        SORT_REGULAR - автоматический выбор сортировки (установлен по умолчанию)
        SORT_NUMERIC - числовая сортировка
        SORT_STRING - сортировка по алфавиту
        */
        asort($arr); // выполнить сортировку массива
        showArray(arr: $arr, header: "отсортированный по возрастанию массив");
    }


    // compact -> создание массива из переменных, где ключами становятся имена переменных, а значениями значения переменных
    function ex4(){
        // Важно! В compact нужно вводить имена переменных в строковом виде
        $a = 100;
        $b = 200;
        $c = 300;
        $arr = compact("a","b","c"); // переменные передаются в строковом виде
        showArray(arr: $arr, header: "Массив созаднный из переменных");

    }

    // shuffle -> перемешивает элемены массива в случайном порядке. изменяет массив на месте
    function ex3(){
        $arr = ["a","b","c","d","e","f","g"];

        showArray(arr: $arr,header: "Исходный массив");
        shuffle($arr);
        showArray(arr: $arr,header: "Перемешанный массив");
    }

    // count и sizeof -> подсчёт количества элементов массива - узнать длину массива
    function ex2(){
        $arr = ["a","b","c","d","e","f","g"];
        echo count($arr)."<br>";
        echo sizeof($arr)."<br>";
    }


    // is_array, проверка, что объект является массивом
    function ex1(){
        $arr = [1,2,3,4];
        echo is_array($arr)."<br>";
        echo (is_array($arr))?"массив":"не массив";
    }