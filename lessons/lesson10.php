<?php
    /**
     * По сути массив в php очень интересный тип данных, он представляет собой некий гибрид списка и словаря в python.
     * При этом он является упорядоченной коллекцией и в одном массиве могут сосуществовать как индексные элементы так 
     * и ассоциативные.
     * В примерах ниже рассмотрим подробно основные методы взаимодействия с этой коллекцией
     */

    // // ОСНОВНЫЕ МЕТОДЫ РАБОТЫ С МАССИВАМИ //
    // ex1(); // индексный массив (нумерация проставляется с 0 и дальше по порядку по умолчанию 0,1,2,3...)
    // ex2(); // ассоциативный массив (используются именованные ключи, можно комбинировать ассоциативный массив с индексным)
    // ex3(); // вложенные массивы
    // ex4(); // "CRUD" операции по работе с массивами (чтение, редактирование, добавление, удаление)
    // ex5(); // поведение индексов в массиве, совмещение индексных и ассоциативных элементов
    // ex6(); // как посмотреть длину массива? функции count() и sizeof()
    // ex7(); // как проверить что в массиве есть ключ array_key_exists()
    // ex8(); // проверка что элемент есть в массиве in_array()
    // ex9(); // поиск элемента в массиве, поиск ключа по значению array_search()
    // ex10(); // получение ключей массива array_keys(), получение значений массива array_values()
    // ex11(); // фильтрация массива, с созданием нового массива на основе callback функции сравнения array_filter()
    // ex12(); // методы array_push(arr, val) добавление элемента в конец массива, array_pop(arr) удаление последнего элемента с записью его в переменную
    // ex13(); // методы массива array_shift удаляет элемент в начале массива возвращая его, array_unshift добавляет произвольное кол-во элементов в начало массива (смещая индексы)
    // ex14(); // получение среза (части) массива по индексу и длине array_slice($arr, offset, length), флаг true для изменения поведения обработки строково-числовых ключей
    // ex15(); // array_splice удаляет элементы из массива и если передан дополнительный массив то вставит элементы вместо него
    // ex16(); // array_reduce функция аккумулирует значения массива, складывая предыдущее значение со следующим и возвращает конечный результат (то есть её смысл приведение массива к одному результату)
    ex17(); // array_map, так же как и в python просто применяет функцию к элементам массива



    // индексный массив (нумерация проставляется с 0 и дальше по порядку по умолчанию 0,1,2,3...)
    function ex1(){
        $arr = [0,1,2,3,4,5,6];
        echo "<pre>";
        print_r($arr);
        echo "</pre>";
    }

    // ассоциативный массив (используются именованные ключи, можно комбинировать ассоциативный массив с индексным)
    function ex2(){
        $user = [
            'имя' => 'Иван',
            'возраст' => 30,
            'город' => 'Санкт-Петербург',

        ];

        echo "<pre>";
        print_r($user);
        echo "</pre>";
    }

    // вложенные массивы
    function ex3(){
        $users = [
            '001' => [
                'имя' => 'Иван',
                'возраст' => 30,
                'город' => 'Санкт-Петербург',
            ],
            '002' => [
                'имя' => 'Светлана',
                'возраст' => 28,
                'город' => 'Петрозаводск',
            ],
        ];

        echo "<pre>";
        print_r($users);
        echo "</pre>";
    }

    // "CRUD" операции по работе с массивами (чтение, редактирование, добавление, удаление)
    function ex4(){
        $arr = ["a","b","c","d"];
        // обращение (чтение) ячейки массива
        echo "<h4>Чтение ячеек массива по индексам(Read)</h4>";
        echo $arr[2]."<br>"; // выведется c (так как индексы идут с 0)
        echo $arr[1]."<br>"; // выведется b

        echo "<h4>Редактирование ячеек массива(Update)</h4>";
        // редактирование ячейки массива:
        $arr[1] = "w"; // перезаписываем значение 1 индексе массива
        echo $arr[1]."<br>"; // теперь вместо b будет храниться w

        echo "<h4>Добавление элемента в массив (Create)</h4>";
        // добавление элемента массива:
        /**первый способ добавляем новый индекс и значение, теперь e добавится в конец массива под индексом 4
        можно также добавить индекс и 100 и 500 и любой вообще. нумерация не важна, главное чтобы индекс был не существующим
        иначе произойдёт просто перезапись уже существующего значения
        */
        $arr[4] = "e"; 
        $arr[50] = "q"; // добавили новое значение с произвольным индексом 50
        
        // посмотрим результат:
        echo "<pre>";
        print_r($arr);
        echo "</pre>";

        /**
         * Второй способ добавления элемента в массив. при этом индекс будет сформирован автоматически на базе последнего 
         * индексного ключа +1, например массив [0,1,2], вставим 3, и этот элемент получит индекс 3
         */
        $arr[] = "h"; // второй способ вставки элемента в массив
        echo "<pre>";
        print_r($arr);
        echo "</pre>";

        echo "<h4>Удаление элемента массива (Delete)</h4>";
        /**
         * Удаление элемента массива можно сделать с помощью функции unset()
         */
        unset($arr[0]); // удаляем элемент по индексу (ключу)
        unset($arr[4]);
        unset($arr[50]);
        echo "<pre>";
        print_r($arr);
        echo "</pre>";
    }

    // поведение индексов в массиве, совмещение индексных и ассоциативных элементов
    function ex5(){
        /**
         * Внизу объявляется массив, как видно в нем есть и индексные и ассоциативные элементы.
         * Индексы будут идти в своем порядки, например 0, а вот где добавлен ключ "test_a", это место пропускается, 
         * и следующему после него индексному элементу будет присвоен индекс 1.
         */
        $arr = [
            0,
            "test_a" => 123,
            1, // будет присвоен индекс 1
            2, // будет присвоен индекс 2
            3, // будет присвоен индекс 3
            4, // будет присвоен индекс 4
        ];
        /** Также у массивов в php есть сохранение индексов, например удалим элемент с индексом $arr[3], но при этом
         * у следующего элемента 4, индекс так и останется на 4, не смотря на пропуск в последовательности
         */
        unset($arr[3]);
          
        echo "<pre>";
        print_r($arr);
        echo "</pre>";
    }

    // как посмотреть длину массива? функции count() и sizeof()
    function ex6(){
        $arr = [0,1,2,3,4];
        echo "Длина массива arr, составляет: ".count($arr)."<br>";
        echo "Длина массива arr, составляет: ".sizeof($arr)."<br>";
    }

    // как проверить что в массиве есть ключ?
    function ex7(){
        $arr = ["a","b","c","d","e","f",];
        var_dump(array_key_exists(3,$arr)); // true, так как 3 действительно есть в этом массиве (3 это ключ-индекс)
        echo "<br>";
        var_dump(array_key_exists(300,$arr)); // false, так как ключ 300 отсутствует в массиве
        echo "<br>";
    }

    // проверка что элемент есть в массиве in_array
    function ex8(){
        $arr = ["a","b","c","d","e","f",];
        var_dump(in_array("b", $arr));
        echo "<br>";
    }

    // поиск элемента в массиве, поиск ключа по значению array_search
    function ex9(){
        $arr = ["a","b","c","d","e","f",];
        $res = array_search("c", $arr, true); // искомое значение, массив, строгое сравнение (да или нет)
        echo $res;
        echo "<br>";
    }

    // получение ключей массива array_keys(), получение значений массива array_values()
    function ex10(){
        // чтобы получить список ключей использовать array_keys
        $arr = ["a" => 123, "b" => 456, "c" => 789, "d" => 123];
        $keys = array_keys($arr, 123); // можно использовать фильтр для поиска, теперь выведутся только те ключи значение которых 123
        echo "<pre>";
        print_r($keys);
        echo "</pre>";

        // также можно получить массив со значениями, но фильтры здесь не предусмотрены, см. array_filter
        $keys = array_values($arr);
        echo "<pre>";
        print_r($keys);
        echo "</pre>";
    }


    // фильтрация массива, с созданием нового массива на основе callback функции сравнения
    function ex11(){
        /* callback функцией в данном случае является even, она должна возвращать либо 
            true (то есть элемент удовлетворяет условию и значит он добавится в новый массив), 
            либо false (элемент не прошел фильтрацию) 
            Функция array_filter принимает в себя 3 аргумента:
            (массив, callback функция, что передавать)
            3 параметр необязательный, он по умолчанию передает значения массива в callback функцию, но можно передавать и ключи
            переключаться можно с помощью 
            ARRAY_FILTER_USE_BOTH - передавать значения массива (по умолчанию работает именно этот режим)
            ARRAY_FILTER_USE_KEY - передавать ключи массива
        */

        // эта функция просто проверяет, чётное число или нет
        function even($var){ // проверяем что на вход подано именно целое число
            if (!(gettype($var)=='integer')){ // если это не так вернем false, то есть результат не попадёт в фильтрацию
                return false;
            }
            return ($var % 2 == 0);
        }

        // фильтруем по значениям (ARRAY_FILTER_USE_BOTH):
        $arr1 = ["a" => 1, "b" => 2, "c" => 3, "d" => 4, "e" => 5, "f" => 6];
        $filter_arr = array_filter($arr1, "even", ARRAY_FILTER_USE_BOTH);
        echo "<pre>";
        print_r($filter_arr);
        echo "</pre>";

        // фильтруем по ключам массива (ARRAY_FILTER_USE_KEY):
        $arr2 = ["a","b","c","d","e","f","g"];
        $filter_arr2 = array_filter($arr2, "even", ARRAY_FILTER_USE_KEY);
        echo "<pre>";
        print_r($filter_arr2);
        echo "</pre>";
    }

    // методы array_push(arr, val) добавление элемента в конец массива, array_pop(arr) удаление последнего элемента с записью его в переменную
    function ex12(){
        $arr = ["a","b","c"];
        $arr[] = "d"; // этот способ вставки добавляет новый элемент в конец массива (если не указан ключ)
        array_push($arr, "e"); // этот метод также добавляет элемент в конец массива (такой же как и $arr[]=value)
        $element = array_pop($arr); // удаляет последний элемент массива возвращая его в переменную
        echo $element;
        echo "<pre>";
        print_r($arr);
        echo "</pre>";
    }


    // методы массива array_shift удаляет элемент в начале массива возвращая его, array_unshift добавляет произвольное кол-во элементов в начало массива (смещая индексы)
    function ex13(){
        $arr = ["a","b","c"];

        /* 
            * метод array_shift удаляет первый элемент массива, возвращая его в переменную или пустой массив
            * если элемент отсутствует в коллекции
            * Индексный ряд при этом сместился на 1
            */
        $variable = array_shift($arr);
        echo $variable;
        echo "<pre>";
        print_r($arr);
        echo "</pre>";

        /**
         * Метод array_unshift добавляет произвольное количество аргументов в начало массива, при 
         * этом индексный ряд смещается на это же количество элементов, то есть индексы начинаются
         * с этих (вставленных) элементов 0 1 2 3 ...
         */
        array_unshift($arr, "w","q");
        echo $variable;
        echo "<pre>";
        print_r($arr);
        echo "</pre>";
    }


    // получение среза (части) массива по индексу и длине array_slice($arr, offset, length), флаг true для изменения поведения обработки строково-числовых ключей
    function ex14(){
        /** принцип функции array_slice в том. что указывается сам массив, стартовый индекс (элементы)
         * начиная с которого мы проссматриваем дальше n элементов, то есть это работает по принципу
         * offset и limit (например в sql базах данных)
         */
        $arr = ["a","b","c","d","e","f","g"];
        $arr_result =array_slice($arr, 2, 3);
        echo "<pre>";
        print_r($arr_result);
        echo "</pre>";

        /** если массив ассоциативный и в нем есть ключи которые представлены в виде строк но это числа
         * то индекс будет сбрасываться на нумерацию, то есть 0 1 2 3...
         * чтобы изменить это поведение, нужно поставить флаг true
         * 
        */
        $arr2 = ["a" => 123, "b" => 456, "100" => 789, "200" => 1000];
        echo "<pre>";
        print_r(array_slice($arr2, 0, 4));
        echo "<br>";
        print_r(array_slice($arr2, 0, 4, true));
        echo "</pre>";
    }


    //array_splice удаляет элементы из массива и если передан дополнительный массив то вставит элементы вместо него
    function ex15(){
        /** array_splice удаляет элементы из массива и если передан дополнительный массив то вставит элементы вместо него */
        $arr = ["a","b","c","d","e","f",];
        array_splice($arr, 1, 2, array("w","r")); // теперь эти элементы w r, будут на месте b и c
        array_splice($arr, 4, 5); // элементы e f удалятся
        echo "<pre>";
        print_r($arr);
        echo "</pre>";
    }


    // array_reduce функция аккумулирует значения массива, складывая предыдущее значение со следующим и возвращает конечный результат (то есть её смысл приведение массива к одному результату)
    function ex16(){
        /* 
            * array_reduce функция аккумулирует значения массива, складывая предыдущее значение со следующим и 
            * возвращает конечный результат (то есть её смысл приведение массива к одному результату)
            * также в reduce можно передать третий необязательный аргумент initial, который добавится вычислениям массива
            */
        function sum($a, $b){
            return $a+$b;
        }

        $arr = [10,20,30,40,50];
        $res = array_reduce($arr, "sum", 1000);
        echo $res;
    }

    // array_map, так же как и в python просто применяет функцию к элементам массива
    function ex17(){
        function upper($n){
            return  strtoupper($n);
        }

        $arr = ["a","b","c","d","e","f"];
        $arr = array_map("upper",$arr);
        echo "<pre>";
        print_r($arr);
        echo "</pre>";
    }